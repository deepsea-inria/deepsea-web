<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Theory and practice of chunked sequences" />
  <title>chunkedseq</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="chunkedseq.css" type="text/css" />
</head>
<body>
<div id="header">
<h1 class="title">chunkedseq</h1>
<h2 class="author">Theory and practice of chunked sequences</h2>
<h3 class="date"><a href="http://deepsea.inria.fr/">Deepsea project</a></h3>
</div>
<h1 id="overview">Overview</h1>
<p>In this project, we address the question:</p>
<blockquote>
<p><em>Can we design asymptotically and practically efficient data structures for sequences that can support a broad range of operations, including push/pop operations on both ends, concatenation, and split at a specified position?</em></p>
</blockquote>
<p>In our ESA’14 paper,<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> we present two new algorithms for which we use adaptations of the classic chunking technique for accelerating tree-based representations of sequences by representing sequences as trees of small, fixed-capacity arrays (i.e., chunks). We prove that our algorithms deliver tight amortized, worst-case bounds with small constant factors. We present two C++ implementations of our two algorithms and a number of experiments comparing our implementations to highly tuned and specialized sequence data structures, such as STL deque and STL rope. This work presents the first data structures for shared memory that simultaneously match the semantic and asymptotic profile of the Finger Tree of Hinze and Patterson,<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> deliver strong guarantees with respect to constant-factor performance (as well as asymptotic performance), and compete well with highly tuned but more specialized data structures.</p>
<p>We have made available a long version of our ESA’14 article which includes appendices. In the appendix, there is additional discussion of experiments, extra experimental results, and proofs.</p>
<ul>
<li><a href="http://deepsea.inria.fr/chunkedseq/esa-2014-long.pdf">Article</a> (long version)</li>
<li><a href="http://www.chargueraud.org/talks/2014_09_08_talk_esa_chunked.pdf">Slides from talk</a></li>
</ul>
<h1 id="source-code-and-documentation">Source code and documentation</h1>
<p>Our source code is hosted on a <a href="https://github.com/deepsea-inria/chunkedseq">Github repository</a>.</p>
<p>Documentation is available in <a href="doc/chunkedseq.html">HTML</a> or <a href="doc/chunkedseq.pdf">PDF</a> format.</p>
<h1 id="running-and-extending-our-expriments">Running and extending our expriments</h1>
<p>We encourage others to evaluate the findings of our empirical study. To this end, we provide the source code of our benchmarks along with the following instructions that show what steps a reviewer can take to repeat our experiments and to interpret the data.</p>
<p>If you have trouble completing this process, please send email describing the issue to <script type="text/javascript">
<!--
h='&#x69;&#110;&#114;&#x69;&#x61;&#46;&#102;&#114;';a='&#64;';n='&#x6d;&#x69;&#x6b;&#x65;&#46;&#114;&#x61;&#x69;&#110;&#x65;&#x79;';e=n+a+h;
document.write('<a h'+'ref'+'="ma'+'ilto'+':'+e+'" clas'+'s="em' + 'ail">'+'&#x4d;&#x69;&#x6b;&#x65;&#32;&#82;&#x61;&#x69;&#110;&#x65;&#x79;'+'<\/'+'a'+'>');
// -->
</script><noscript>&#x4d;&#x69;&#x6b;&#x65;&#32;&#82;&#x61;&#x69;&#110;&#x65;&#x79;&#32;&#40;&#x6d;&#x69;&#x6b;&#x65;&#46;&#114;&#x61;&#x69;&#110;&#x65;&#x79;&#32;&#x61;&#116;&#32;&#x69;&#110;&#114;&#x69;&#x61;&#32;&#100;&#x6f;&#116;&#32;&#102;&#114;&#x29;</noscript>.</p>
<h2 id="prerequisites">1. Prerequisites</h2>
<p>To have enough room to run the experiments, your filesystem should have about 80GB of free space and your machine at least 8GB or RAM. These space requirements are so large because, for our graph-search benchmarks, we use a few very large graphs. In addition to those listed above, the following packages should be installed on your test machine.</p>
<table>
<colgroup>
<col width="13%" />
<col width="18%" />
<col width="63%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Package</th>
<th align="left">Version</th>
<th align="left">Details</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">ocaml</td>
<td align="left">&gt;= 4.00</td>
<td align="left">This compiler is required to build our benchmarking scripts. <a href="http://www.ocaml.org/">Source.</a></td>
</tr>
<tr class="even">
<td align="left">R</td>
<td align="left">&gt;= 2.4.1</td>
<td align="left">This plotting package is required to render plots. <a href="http://www.r-project.org/">Source.</a></td>
</tr>
<tr class="odd">
<td align="left">wget</td>
<td align="left">(recent)</td>
<td align="left">The benchmarking script invokes this script to download graph data. <a href="http://www.gnu.org/software/wget/">Source.</a></td>
</tr>
<tr class="even">
<td align="left">latex</td>
<td align="left">(recent)</td>
<td align="left">Tables of results are generated in and compiled by latex. <a href="http://www.latex-project.org/">Source.</a></td>
</tr>
<tr class="odd">
<td align="left">jemalloc</td>
<td align="left">&gt;= 3.6.0</td>
<td align="left">Optionally used by our benchmarking programs to improve performance. <a href="http://www.canonware.com/jemalloc/">Source.</a></td>
</tr>
</tbody>
</table>
<h2 id="getting-the-source-code">2. Getting the source code</h2>
<p>You can either download our source files via <a href="http://deepsea.inria.fr/chunkedseq/experiments/chunkedseq_bench.tar.gz">this link</a> or, if you prefer to use wget, you can skip to the next stage.</p>
<p>You can find relevant files in the following places:</p>
<table>
<colgroup>
<col width="48%" />
<col width="48%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Locations</th>
<th align="left">Details</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>chunkedseq/include/*.hpp</code></td>
<td align="left">implementation-specific files</td>
</tr>
<tr class="even">
<td align="left"><code>chunkedseq/bench/bench.cpp</code> <code>chunkedseq/bench/do_fifo.cpp</code></td>
<td align="left">sequence-specific benchmarking codes</td>
</tr>
<tr class="odd">
<td align="left"><code>graph/bench/search.cpp</code> <code>graph/include/*.hpp</code></td>
<td align="left">graph-search benchmarking codes</td>
</tr>
<tr class="even">
<td align="left"><code>chunkedseq/stl/pushpop.cpp</code></td>
<td align="left">STL worst-case benchmark</td>
</tr>
</tbody>
</table>
<h2 id="running-experiments">3. Running experiments</h2>
<p>To get started, first download our source file, unpackage, and build our benchmarking script, namely <code>chunkedseq.byte</code>.</p>
<pre><code>$ wget http://deepsea.inria.fr/chunkedseq/experiments/chunkedseq_bench.tar.gz
$ tar -xvzf chunkedseq_bench.tar.gz
$ cd chunkedseq_bench/pbench
$ make chunkedseq.byte</code></pre>
<p>We need to do a little configuration before we can start running the benchmarks. We found that we could get best results in our experiments by using a custom implementation of malloc/free called <a href="http://www.canonware.com/jemalloc/">jemalloc</a>. The custom allocator is optional. If you do not want to use it, then simply run:</p>
<pre><code>$ ./chunkedseq.byte configure</code></pre>
<p>Otherwise, run the following command, replacing <code>JEMALLOC_PATH</code> by the path to the folder which contains the shared object files of jemalloc.</p>
<pre><code>$ ./chunkedseq.byte configure -allocator jemalloc \
        -path_to_jemalloc JEMALLOC_PATH</code></pre>
<p>The following command starts the process. You may need to wait a few hours for the process to complete.</p>
<pre><code>$ ./chunkedseq.byte paper</code></pre>
<p>During the initialization phase, our script builds several binaries and generates input data required by the graph-search experiments. The input data may take about 30GB in total. Our script puts the input data into the folder <code>_data</code>. After initialization completes, the experiments run. During this time, be careful to ensure that the machine is quiet (except for the currently running experiment). Results from the experiments go into a new folder that is created by the script. The name of this folder is reported by the script after the script completes.</p>
<h2 id="interpreting-results">4. Interpreting results</h2>
<p>When all of the experiments run to completion, results should be generated by the script and put into the following files.</p>
<table>
<colgroup>
<col width="48%" />
<col width="48%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Locations</th>
<th align="left">Details</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>tables_paper.tex</code>; <code>tables_paper.pdf</code></td>
<td align="left">report of all experiments, showing runtimes in seconds</td>
</tr>
<tr class="even">
<td align="left"><code>tables_</code><em>exp</em><code>.tex</code>; <code>tables_</code><em>exp</em><code>.pdf</code></td>
<td align="left">one table for each indidual experiment <em>exp</em></td>
</tr>
<tr class="odd">
<td align="left"><code>_results/results_</code><em>exp</em><code>.txt</code></td>
<td align="left">raw input/output of each run for each individual experiment <em>exp</em></td>
</tr>
<tr class="even">
<td align="left"><code>plots_chunk_size.pdf</code></td>
<td align="left">a scatter plot showing the results of the chunk-size experiment</td>
</tr>
</tbody>
</table>
<h2 id="advanced-benchmarking">5. Advanced benchmarking</h2>
<p>Our benchmarking script supports a range of configurations that are not discussed here. Refer to the following documentation for details:</p>
<ul>
<li><a href="experiments/chunkedseq.pdf">PDF</a></li>
<li><a href="experiments/chunkedseq.html">HTML</a></li>
<li><a href="experiments/chunkedseq.md">Markdown</a></li>
</ul>
<h1 id="team">Team</h1>
<ul>
<li><a href="http://www.umut-acar.org/site/umutacar/">Umut Acar</a></li>
<li><a href="http://www.chargueraud.org/">Arthur Charguéraud</a></li>
<li><a href="http://gallium.inria.fr/~rainey/">Mike Rainey</a></li>
</ul>
<h1 id="references">References</h1>
<p>Get the <a href="chunkedseq.bib">bibtex file</a> used to generate these references.</p>
<div class="references">
<div id="ref-chunkedseq14-esa">
<p>Acar, Umut A., Arthur Charguéraud, and Mike Rainey. 2014. “Theory and Practice of Chunked Sequences.” In <em>ESA 2014</em>, 8737:25–36. LNCS. Springer Berlin Heidelberg. <a href="http://doi.org/10.1007/978-3-662-44777-2_3">doi:10.1007/978-3-662-44777-2_3</a>.</p>
</div>
<div id="ref-finger-trees">
<p>Hinze, Ralf, and Ross Paterson. 2006. “Finger Trees: A Simple General-Purpose Data Structure.” <em>Journal of Functional Programming</em> 16 (2). New York, NY, USA: Cambridge University Press: 197–217. <a href="http://doi.org/10.1017/S0956796805005769">doi:10.1017/S0956796805005769</a>.</p>
</div>
</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p><span class="citation">(Acar, Charguéraud, and Rainey 2014)</span><a href="#fnref1">↩</a></p></li>
<li id="fn2"><p><span class="citation">(Hinze and Paterson 2006)</span><a href="#fnref2">↩</a></p></li>
</ol>
</div>
</body>
</html>
